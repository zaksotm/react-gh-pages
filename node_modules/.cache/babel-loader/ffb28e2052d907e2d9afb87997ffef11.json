{"ast":null,"code":"'use strict';\n\nvar Potrace = require('./Potrace');\n\nvar utils = require('./utils');\n/**\r\n * Takes multiple samples using {@link Potrace} with different threshold\r\n * settings and combines output into a single file.\r\n *\r\n * @param {Posterizer~Options} [options]\r\n * @constructor\r\n */\n\n\nfunction Posterizer(options) {\n  this._potrace = new Potrace();\n  this._calculatedThreshold = null;\n  this._params = {\n    threshold: Potrace.THRESHOLD_AUTO,\n    blackOnWhite: true,\n    steps: Posterizer.STEPS_AUTO,\n    background: Potrace.COLOR_TRANSPARENT,\n    fillStrategy: Posterizer.FILL_DOMINANT,\n    rangeDistribution: Posterizer.RANGES_AUTO\n  };\n\n  if (options) {\n    this.setParameters(options);\n  }\n} // Inherit constants from Potrace class\n\n\nfor (var key in Potrace) {\n  if (Object.prototype.hasOwnProperty.call(Potrace, key) && key === key.toUpperCase()) {\n    Posterizer[key] = Potrace[key];\n  }\n}\n\nPosterizer.STEPS_AUTO = -1;\nPosterizer.FILL_SPREAD = 'spread';\nPosterizer.FILL_DOMINANT = 'dominant';\nPosterizer.FILL_MEDIAN = 'median';\nPosterizer.FILL_MEAN = 'mean';\nPosterizer.RANGES_AUTO = 'auto';\nPosterizer.RANGES_EQUAL = 'equal';\nPosterizer.prototype = {\n  /**\r\n   * Fine tuning to color ranges.\r\n   *\r\n   * If last range (featuring most saturated color) is larger than 10% of color space (25 units)\r\n   * then we want to add another color stop, that hopefully will include darkest pixels, improving presence of\r\n   * shadows and line art\r\n   *\r\n   * @param ranges\r\n   * @private\r\n   */\n  _addExtraColorStop: function (ranges) {\n    var blackOnWhite = this._params.blackOnWhite;\n    var lastColorStop = ranges[ranges.length - 1];\n    var lastRangeFrom = blackOnWhite ? 0 : lastColorStop.value;\n    var lastRangeTo = blackOnWhite ? lastColorStop.value : 255;\n\n    if (lastRangeTo - lastRangeFrom > 25 && lastColorStop.colorIntensity !== 1) {\n      var histogram = this._getImageHistogram();\n\n      var levels = histogram.getStats(lastRangeFrom, lastRangeTo).levels;\n      var newColorStop = levels.mean + levels.stdDev <= 25 ? levels.mean + levels.stdDev : levels.mean - levels.stdDev <= 25 ? levels.mean - levels.stdDev : 25;\n      var newStats = blackOnWhite ? histogram.getStats(0, newColorStop) : histogram.getStats(newColorStop, 255);\n      var color = newStats.levels.mean;\n      ranges.push({\n        value: Math.abs((blackOnWhite ? 0 : 255) - newColorStop),\n        colorIntensity: isNaN(color) ? 0 : (blackOnWhite ? 255 - color : color) / 255\n      });\n    }\n\n    return ranges;\n  },\n\n  /**\r\n   * Calculates color intensity for each element of numeric array\r\n   * \r\n   * @param {number[]} colorStops\r\n   * @returns {{ levels: number, colorIntensity: number }[]}\r\n   * @private\r\n   */\n  _calcColorIntensity: function (colorStops) {\n    var blackOnWhite = this._params.blackOnWhite;\n    var colorSelectionStrat = this._params.fillStrategy;\n    var histogram = colorSelectionStrat !== Posterizer.FILL_SPREAD ? this._getImageHistogram() : null;\n    var fullRange = Math.abs(this._paramThreshold() - (blackOnWhite ? 0 : 255));\n    return colorStops.map(function (threshold, index) {\n      var nextValue = index + 1 === colorStops.length ? blackOnWhite ? -1 : 256 : colorStops[index + 1];\n      var rangeStart = Math.round(blackOnWhite ? nextValue + 1 : threshold);\n      var rangeEnd = Math.round(blackOnWhite ? threshold : nextValue - 1);\n      var factor = index / (colorStops.length - 1);\n      var intervalSize = rangeEnd - rangeStart;\n      var stats = histogram.getStats(rangeStart, rangeEnd);\n      var color = -1;\n\n      if (stats.pixels === 0) {\n        return {\n          value: threshold,\n          colorIntensity: 0\n        };\n      }\n\n      switch (colorSelectionStrat) {\n        case Posterizer.FILL_SPREAD:\n          // We want it to be 0 (255 when white on black) at the most saturated end, so...\n          color = (blackOnWhite ? rangeStart : rangeEnd) + (blackOnWhite ? 1 : -1) * intervalSize * Math.max(0.5, fullRange / 255) * factor;\n          break;\n\n        case Posterizer.FILL_DOMINANT:\n          color = histogram.getDominantColor(rangeStart, rangeEnd, utils.clamp(intervalSize, 1, 5));\n          break;\n\n        case Posterizer.FILL_MEAN:\n          color = stats.levels.mean;\n          break;\n\n        case Posterizer.FILL_MEDIAN:\n          color = stats.levels.median;\n          break;\n      } // We don't want colors to be too close to each other, so we introduce some spacing in between\n\n\n      if (index !== 0) {\n        color = blackOnWhite ? utils.clamp(color, rangeStart, rangeEnd - Math.round(intervalSize * 0.1)) : utils.clamp(color, rangeStart + Math.round(intervalSize * 0.1), rangeEnd);\n      }\n\n      return {\n        value: threshold,\n        colorIntensity: color === -1 ? 0 : (blackOnWhite ? 255 - color : color) / 255\n      };\n    });\n  },\n\n  /**\r\n   * @returns {Histogram}\r\n   * @private\r\n   */\n  _getImageHistogram: function () {\n    return this._potrace._luminanceData.histogram();\n  },\n\n  /**\r\n   * Processes threshold, steps and rangeDistribution parameters and returns normalized array of color stops\r\n   * @returns {*}\r\n   * @private\r\n   */\n  _getRanges: function () {\n    var steps = this._paramSteps();\n\n    if (!Array.isArray(steps)) {\n      return this._params.rangeDistribution === Posterizer.RANGES_AUTO ? this._getRangesAuto() : this._getRangesEquallyDistributed();\n    } // Steps is array of thresholds and we want to preprocess it\n\n\n    var colorStops = [];\n\n    var threshold = this._paramThreshold();\n\n    var lookingForDarkPixels = this._params.blackOnWhite;\n    steps.forEach(function (item) {\n      if (colorStops.indexOf(item) === -1 && utils.between(item, 0, 255)) {\n        colorStops.push(item);\n      }\n    });\n\n    if (!colorStops.length) {\n      colorStops.push(threshold);\n    }\n\n    colorStops = colorStops.sort(function (a, b) {\n      return a < b === lookingForDarkPixels ? 1 : -1;\n    });\n\n    if (lookingForDarkPixels && colorStops[0] < threshold) {\n      colorStops.unshift(threshold);\n    } else if (!lookingForDarkPixels && colorStops[colorStops.length - 1] < threshold) {\n      colorStops.push(threshold);\n    }\n\n    return this._calcColorIntensity(colorStops);\n  },\n\n  /**\r\n   * Calculates given (or lower) number of thresholds using automatic thresholding algorithm\r\n   * @returns {*}\r\n   * @private\r\n   */\n  _getRangesAuto: function () {\n    var histogram = this._getImageHistogram();\n\n    var steps = this._paramSteps(true);\n\n    var colorStops;\n\n    if (this._params.threshold === Potrace.THRESHOLD_AUTO) {\n      colorStops = histogram.multilevelThresholding(steps);\n    } else {\n      var threshold = this._paramThreshold();\n\n      colorStops = this._params.blackOnWhite ? histogram.multilevelThresholding(steps - 1, 0, threshold) : histogram.multilevelThresholding(steps - 1, threshold, 255);\n\n      if (this._params.blackOnWhite) {\n        colorStops.push(threshold);\n      } else {\n        colorStops.unshift(threshold);\n      }\n    }\n\n    if (this._params.blackOnWhite) {\n      colorStops = colorStops.reverse();\n    }\n\n    return this._calcColorIntensity(colorStops);\n  },\n\n  /**\r\n   * Calculates color stops and color representing each segment, returning them\r\n   * from least to most intense color (black or white, depending on blackOnWhite parameter)\r\n   *\r\n   * @private\r\n   */\n  _getRangesEquallyDistributed: function () {\n    var blackOnWhite = this._params.blackOnWhite;\n    var colorsToThreshold = blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();\n\n    var steps = this._paramSteps();\n\n    var stepSize = colorsToThreshold / steps;\n    var colorStops = [];\n    var i = steps - 1,\n        factor,\n        threshold;\n\n    while (i >= 0) {\n      factor = i / (steps - 1);\n      threshold = Math.min(colorsToThreshold, (i + 1) * stepSize);\n      threshold = blackOnWhite ? threshold : 255 - threshold;\n      i--;\n      colorStops.push(threshold);\n    }\n\n    return this._calcColorIntensity(colorStops);\n  },\n\n  /**\r\n   * Returns valid steps value\r\n   * @param {Boolean} [count=false]\r\n   * @returns {number|number[]}\r\n   * @private\r\n   */\n  _paramSteps: function (count) {\n    var steps = this._params.steps;\n\n    if (Array.isArray(steps)) {\n      return count ? steps.length : steps;\n    }\n\n    if (steps === Posterizer.STEPS_AUTO && this._params.threshold === Potrace.THRESHOLD_AUTO) {\n      return 4;\n    }\n\n    var blackOnWhite = this._params.blackOnWhite;\n    var colorsCount = blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();\n    return steps === Posterizer.STEPS_AUTO ? colorsCount > 200 ? 4 : 3 : Math.min(colorsCount, Math.max(2, steps));\n  },\n\n  /**\r\n   * Returns valid threshold value\r\n   * @returns {number}\r\n   * @private\r\n   */\n  _paramThreshold: function () {\n    if (this._calculatedThreshold !== null) {\n      return this._calculatedThreshold;\n    }\n\n    if (this._params.threshold !== Potrace.THRESHOLD_AUTO) {\n      this._calculatedThreshold = this._params.threshold;\n      return this._calculatedThreshold;\n    }\n\n    var twoThresholds = this._getImageHistogram().multilevelThresholding(2);\n\n    this._calculatedThreshold = this._params.blackOnWhite ? twoThresholds[1] : twoThresholds[0];\n    this._calculatedThreshold = this._calculatedThreshold || 128;\n    return this._calculatedThreshold;\n  },\n\n  /**\r\n   * Running potrace on the image multiple times with different thresholds and returns an array\r\n   * of path tags\r\n   *\r\n   * @param {Boolean} [noFillColor]\r\n   * @returns {string[]}\r\n   * @private\r\n   */\n  _pathTags: function (noFillColor) {\n    var ranges = this._getRanges();\n\n    var potrace = this._potrace;\n    var blackOnWhite = this._params.blackOnWhite;\n\n    if (ranges.length >= 10) {\n      ranges = this._addExtraColorStop(ranges);\n    }\n\n    potrace.setParameters({\n      blackOnWhite: blackOnWhite\n    });\n    var actualPrevLayersOpacity = 0;\n    return ranges.map(function (colorStop) {\n      var thisLayerOpacity = colorStop.colorIntensity;\n\n      if (thisLayerOpacity === 0) {\n        return '';\n      } // NOTE: With big number of layers (something like 70) there will be noticeable math error on rendering side.\n      // In Chromium at least image will end up looking brighter overall compared to the same layers painted in solid colors.\n      // However it works fine with sane number of layers, and it's not like we can do much about it.\n\n\n      var calculatedOpacity = !actualPrevLayersOpacity || thisLayerOpacity === 1 ? thisLayerOpacity : (actualPrevLayersOpacity - thisLayerOpacity) / (actualPrevLayersOpacity - 1);\n      calculatedOpacity = utils.clamp(parseFloat(calculatedOpacity.toFixed(3)), 0, 1);\n      actualPrevLayersOpacity = actualPrevLayersOpacity + (1 - actualPrevLayersOpacity) * calculatedOpacity;\n      potrace.setParameters({\n        threshold: colorStop.value\n      });\n      var element = noFillColor ? potrace.getPathTag('') : potrace.getPathTag();\n      element = utils.setHtmlAttr(element, 'fill-opacity', calculatedOpacity.toFixed(3));\n      var canBeIgnored = calculatedOpacity === 0 || element.indexOf(' d=\"\"') !== -1; // var c = Math.round(Math.abs((blackOnWhite ? 255 : 0) - 255 * thisLayerOpacity));\n      // element = utils.setHtmlAttr(element, 'fill', 'rgb('+c+', '+c+', '+c+')');\n      // element = utils.setHtmlAttr(element, 'fill-opacity', '');\n\n      return canBeIgnored ? '' : element;\n    });\n  },\n\n  /**\r\n   * Loads image.\r\n   *\r\n   * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP\r\n   * @param {Function} callback\r\n   */\n  loadImage: function (target, callback) {\n    var self = this;\n\n    this._potrace.loadImage(target, function (err) {\n      self._calculatedThreshold = null;\n      callback.call(self, err);\n    });\n  },\n\n  /**\r\n   * Sets parameters. Accepts same object as {Potrace}\r\n   *\r\n   * @param {Posterizer~Options} params\r\n   */\n  setParameters: function (params) {\n    if (!params) {\n      return;\n    }\n\n    this._potrace.setParameters(params);\n\n    if (params.steps && !Array.isArray(params.steps) && (!utils.isNumber(params.steps) || !utils.between(params.steps, 1, 255))) {\n      throw new Error('Bad \\'steps\\' value');\n    }\n\n    for (var key in this._params) {\n      if (this._params.hasOwnProperty(key) && params.hasOwnProperty(key)) {\n        this._params[key] = params[key];\n      }\n    }\n\n    this._calculatedThreshold = null;\n  },\n\n  /**\r\n   * Returns image as <symbol> tag. Always has viewBox specified\r\n   *\r\n   * @param {string} id\r\n   */\n  getSymbol: function (id) {\n    var width = this._potrace._luminanceData.width;\n    var height = this._potrace._luminanceData.height;\n\n    var paths = this._pathTags(true);\n\n    return '<symbol viewBox=\"0 0 ' + width + ' ' + height + '\" id=\"' + id + '\">' + paths.join('') + '</symbol>';\n  },\n\n  /**\r\n   * Generates SVG image\r\n   * @returns {String}\r\n   */\n  getSVG: function () {\n    var width = this._potrace._luminanceData.width,\n        height = this._potrace._luminanceData.height;\n\n    var tags = this._pathTags(false);\n\n    var svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + 'width=\"' + width + '\" ' + 'height=\"' + height + '\" ' + 'viewBox=\"0 0 ' + width + ' ' + height + '\" ' + 'version=\"1.1\">\\n\\t' + (this._params.background !== Potrace.COLOR_TRANSPARENT ? '<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"' + this._params.background + '\" />\\n\\t' : '') + tags.join('\\n\\t') + '\\n</svg>';\n    return svg.replace(/\\n(?:\\t*\\n)+(\\t*)/g, '\\n$1');\n  }\n};\nmodule.exports = Posterizer;\n/**\r\n * Posterizer options\r\n *\r\n * @typedef {Potrace~Options} Posterizer~Options\r\n * @property {Number} [steps]   - Number of samples that needs to be taken (and number of layers in SVG). (default: Posterizer.STEPS_AUTO, which most likely will result in 3, sometimes 4)\r\n * @property {*} [fillStrategy] - How to select fill color for color ranges - equally spread or dominant. (default: Posterizer.FILL_DOMINANT)\r\n * @property {*} [rangeDistribution] - How to choose thresholds in-between - after equal intervals or automatically balanced. (default: Posterizer.RANGES_AUTO)\r\n */","map":{"version":3,"sources":["/Users/zakstratton/Documents/design-tool/node_modules/potrace/lib/Posterizer.js"],"names":["Potrace","require","utils","Posterizer","options","_potrace","_calculatedThreshold","_params","threshold","THRESHOLD_AUTO","blackOnWhite","steps","STEPS_AUTO","background","COLOR_TRANSPARENT","fillStrategy","FILL_DOMINANT","rangeDistribution","RANGES_AUTO","setParameters","key","Object","prototype","hasOwnProperty","call","toUpperCase","FILL_SPREAD","FILL_MEDIAN","FILL_MEAN","RANGES_EQUAL","_addExtraColorStop","ranges","lastColorStop","length","lastRangeFrom","value","lastRangeTo","colorIntensity","histogram","_getImageHistogram","levels","getStats","newColorStop","mean","stdDev","newStats","color","push","Math","abs","isNaN","_calcColorIntensity","colorStops","colorSelectionStrat","fullRange","_paramThreshold","map","index","nextValue","rangeStart","round","rangeEnd","factor","intervalSize","stats","pixels","max","getDominantColor","clamp","median","_luminanceData","_getRanges","_paramSteps","Array","isArray","_getRangesAuto","_getRangesEquallyDistributed","lookingForDarkPixels","forEach","item","indexOf","between","sort","a","b","unshift","multilevelThresholding","reverse","colorsToThreshold","stepSize","i","min","count","colorsCount","twoThresholds","_pathTags","noFillColor","potrace","actualPrevLayersOpacity","colorStop","thisLayerOpacity","calculatedOpacity","parseFloat","toFixed","element","getPathTag","setHtmlAttr","canBeIgnored","loadImage","target","callback","self","err","params","isNumber","Error","getSymbol","id","width","height","paths","join","getSVG","tags","svg","replace","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar Potrace = require('./Potrace');\r\nvar utils = require('./utils');\r\n\r\n/**\r\n * Takes multiple samples using {@link Potrace} with different threshold\r\n * settings and combines output into a single file.\r\n *\r\n * @param {Posterizer~Options} [options]\r\n * @constructor\r\n */\r\nfunction Posterizer(options) {\r\n  this._potrace = new Potrace();\r\n\r\n  this._calculatedThreshold = null;\r\n  \r\n  this._params = {\r\n    threshold: Potrace.THRESHOLD_AUTO,\r\n    blackOnWhite: true,\r\n    steps: Posterizer.STEPS_AUTO,\r\n    background: Potrace.COLOR_TRANSPARENT,\r\n    fillStrategy: Posterizer.FILL_DOMINANT,\r\n    rangeDistribution: Posterizer.RANGES_AUTO\r\n  };\r\n\r\n  if (options) {\r\n    this.setParameters(options);\r\n  }\r\n}\r\n\r\n// Inherit constants from Potrace class\r\nfor (var key in Potrace) {\r\n  if (Object.prototype.hasOwnProperty.call(Potrace, key) && key === key.toUpperCase()) {\r\n    Posterizer[key] = Potrace[key];\r\n  }\r\n}\r\n\r\nPosterizer.STEPS_AUTO = -1;\r\nPosterizer.FILL_SPREAD = 'spread';\r\nPosterizer.FILL_DOMINANT = 'dominant';\r\nPosterizer.FILL_MEDIAN = 'median';\r\nPosterizer.FILL_MEAN = 'mean';\r\n\r\nPosterizer.RANGES_AUTO = 'auto';\r\nPosterizer.RANGES_EQUAL = 'equal';\r\n\r\nPosterizer.prototype = {\r\n  /**\r\n   * Fine tuning to color ranges.\r\n   *\r\n   * If last range (featuring most saturated color) is larger than 10% of color space (25 units)\r\n   * then we want to add another color stop, that hopefully will include darkest pixels, improving presence of\r\n   * shadows and line art\r\n   *\r\n   * @param ranges\r\n   * @private\r\n   */\r\n  _addExtraColorStop: function(ranges) {\r\n    var blackOnWhite = this._params.blackOnWhite;\r\n    var lastColorStop = ranges[ranges.length - 1];\r\n    var lastRangeFrom = blackOnWhite ? 0 : lastColorStop.value;\r\n    var lastRangeTo = blackOnWhite ? lastColorStop.value : 255;\r\n\r\n    if (lastRangeTo - lastRangeFrom > 25 && lastColorStop.colorIntensity !== 1) {\r\n      var histogram = this._getImageHistogram();\r\n      var levels = histogram.getStats(lastRangeFrom, lastRangeTo).levels;\r\n\r\n      var newColorStop = levels.mean + levels.stdDev <= 25 ? levels.mean + levels.stdDev\r\n        : levels.mean - levels.stdDev <= 25 ? levels.mean - levels.stdDev\r\n        : 25;\r\n\r\n      var newStats = (blackOnWhite ? histogram.getStats(0, newColorStop) : histogram.getStats(newColorStop, 255));\r\n      var color = newStats.levels.mean;\r\n\r\n      ranges.push({\r\n        value: Math.abs((blackOnWhite ? 0 : 255) - newColorStop),\r\n        colorIntensity: isNaN(color) ? 0 : ((blackOnWhite ? 255 - color : color) / 255)\r\n      });\r\n    }\r\n\r\n    return ranges;\r\n  },\r\n\r\n\r\n  /**\r\n   * Calculates color intensity for each element of numeric array\r\n   * \r\n   * @param {number[]} colorStops\r\n   * @returns {{ levels: number, colorIntensity: number }[]}\r\n   * @private\r\n   */\r\n  _calcColorIntensity: function(colorStops) {\r\n    var blackOnWhite = this._params.blackOnWhite;\r\n    var colorSelectionStrat = this._params.fillStrategy;\r\n    var histogram = colorSelectionStrat !== Posterizer.FILL_SPREAD ? this._getImageHistogram() : null;\r\n    var fullRange = Math.abs(this._paramThreshold() - (blackOnWhite ? 0 : 255));\r\n\r\n    return colorStops.map(function(threshold, index) {\r\n      var nextValue = index + 1 === colorStops.length ? (blackOnWhite ? -1 : 256) : colorStops[index + 1];\r\n      var rangeStart = Math.round(blackOnWhite ? nextValue + 1 : threshold);\r\n      var rangeEnd = Math.round(blackOnWhite ? threshold : nextValue - 1);\r\n      var factor = index / (colorStops.length - 1);\r\n      var intervalSize = rangeEnd - rangeStart;\r\n      var stats = histogram.getStats(rangeStart, rangeEnd);\r\n      var color = -1;\r\n\r\n      if (stats.pixels === 0) {\r\n        return {\r\n          value: threshold,\r\n          colorIntensity: 0\r\n        };\r\n      }\r\n\r\n      switch (colorSelectionStrat) {\r\n        case Posterizer.FILL_SPREAD:\r\n          // We want it to be 0 (255 when white on black) at the most saturated end, so...\r\n          color = (blackOnWhite ? rangeStart : rangeEnd)\r\n            + (blackOnWhite ? 1 : -1) * intervalSize * Math.max(0.5, fullRange / 255) * factor;\r\n          break;\r\n        case Posterizer.FILL_DOMINANT:\r\n          color = histogram.getDominantColor(rangeStart, rangeEnd, utils.clamp(intervalSize, 1, 5));\r\n          break;\r\n        case Posterizer.FILL_MEAN:\r\n          color = stats.levels.mean;\r\n          break;\r\n        case Posterizer.FILL_MEDIAN:\r\n          color = stats.levels.median;\r\n          break;\r\n      }\r\n\r\n      // We don't want colors to be too close to each other, so we introduce some spacing in between\r\n      if (index !== 0) {\r\n        color = blackOnWhite\r\n          ? utils.clamp(color, rangeStart, rangeEnd - Math.round(intervalSize * 0.1))\r\n          : utils.clamp(color, rangeStart + Math.round(intervalSize * 0.1), rangeEnd);\r\n      }\r\n\r\n      return {\r\n        value: threshold,\r\n        colorIntensity: color === -1 ? 0 : ((blackOnWhite ? 255 - color : color) / 255)\r\n      };\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @returns {Histogram}\r\n   * @private\r\n   */\r\n  _getImageHistogram: function() {\r\n    return this._potrace._luminanceData.histogram();\r\n  },\r\n\r\n  /**\r\n   * Processes threshold, steps and rangeDistribution parameters and returns normalized array of color stops\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _getRanges: function() {\r\n    var steps = this._paramSteps();\r\n\r\n    if (!Array.isArray(steps)) {\r\n      return this._params.rangeDistribution === Posterizer.RANGES_AUTO\r\n        ? this._getRangesAuto()\r\n        : this._getRangesEquallyDistributed();\r\n    }\r\n\r\n    // Steps is array of thresholds and we want to preprocess it\r\n\r\n    var colorStops = [];\r\n    var threshold = this._paramThreshold();\r\n    var lookingForDarkPixels = this._params.blackOnWhite;\r\n\r\n    steps.forEach(function(item) {\r\n      if (colorStops.indexOf(item) === -1 && utils.between(item, 0, 255)) {\r\n        colorStops.push(item);\r\n      }\r\n    });\r\n\r\n    if (!colorStops.length) {\r\n      colorStops.push(threshold);\r\n    }\r\n\r\n    colorStops = colorStops.sort(function (a, b) {\r\n      return a < b === lookingForDarkPixels ? 1 : -1;\r\n    });\r\n\r\n    if (lookingForDarkPixels && colorStops[0] < threshold) {\r\n      colorStops.unshift(threshold);\r\n    } else if (!lookingForDarkPixels && colorStops[colorStops.length - 1] < threshold) {\r\n      colorStops.push(threshold);\r\n    }\r\n\r\n    return this._calcColorIntensity(colorStops);\r\n  },\r\n\r\n  /**\r\n   * Calculates given (or lower) number of thresholds using automatic thresholding algorithm\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _getRangesAuto: function() {\r\n    var histogram = this._getImageHistogram();\r\n    var steps = this._paramSteps(true);\r\n    var colorStops;\r\n\r\n    if (this._params.threshold === Potrace.THRESHOLD_AUTO) {\r\n      colorStops = histogram.multilevelThresholding(steps);\r\n    } else {\r\n      var threshold = this._paramThreshold();\r\n\r\n      colorStops = this._params.blackOnWhite\r\n        ? histogram.multilevelThresholding(steps - 1, 0, threshold)\r\n        : histogram.multilevelThresholding(steps - 1, threshold, 255);\r\n\r\n      if (this._params.blackOnWhite) {\r\n        colorStops.push(threshold);\r\n      } else {\r\n        colorStops.unshift(threshold);\r\n      }\r\n    }\r\n\r\n    if (this._params.blackOnWhite) {\r\n      colorStops = colorStops.reverse();\r\n    }\r\n\r\n    return this._calcColorIntensity(colorStops);\r\n  },\r\n\r\n  /**\r\n   * Calculates color stops and color representing each segment, returning them\r\n   * from least to most intense color (black or white, depending on blackOnWhite parameter)\r\n   *\r\n   * @private\r\n   */\r\n  _getRangesEquallyDistributed: function() {\r\n    var blackOnWhite = this._params.blackOnWhite;\r\n    var colorsToThreshold = blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();\r\n    var steps = this._paramSteps();\r\n\r\n    var stepSize = colorsToThreshold / steps;\r\n    var colorStops = [];\r\n    var i = steps - 1,\r\n        factor,\r\n        threshold;\r\n\r\n    while (i >= 0) {\r\n      factor = i / (steps - 1);\r\n      threshold = Math.min(colorsToThreshold, (i + 1) * stepSize);\r\n      threshold = blackOnWhite ? threshold : 255 - threshold;\r\n      i--;\r\n\r\n      colorStops.push(threshold);\r\n    }\r\n\r\n    return this._calcColorIntensity(colorStops);\r\n  },\r\n\r\n  /**\r\n   * Returns valid steps value\r\n   * @param {Boolean} [count=false]\r\n   * @returns {number|number[]}\r\n   * @private\r\n   */\r\n  _paramSteps: function(count) {\r\n    var steps = this._params.steps;\r\n\r\n    if (Array.isArray(steps)) {\r\n      return count ? steps.length : steps;\r\n    }\r\n\r\n    if (steps === Posterizer.STEPS_AUTO && this._params.threshold === Potrace.THRESHOLD_AUTO) {\r\n      return 4;\r\n    }\r\n\r\n    var blackOnWhite = this._params.blackOnWhite;\r\n    var colorsCount = blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();\r\n\r\n    return steps === Posterizer.STEPS_AUTO\r\n      ? (colorsCount > 200 ? 4 : 3)\r\n      : Math.min(colorsCount, Math.max(2, steps));\r\n  },\r\n\r\n  /**\r\n   * Returns valid threshold value\r\n   * @returns {number}\r\n   * @private\r\n   */\r\n  _paramThreshold: function() {\r\n    if (this._calculatedThreshold !== null) {\r\n      return this._calculatedThreshold;\r\n    }\r\n\r\n    if (this._params.threshold !== Potrace.THRESHOLD_AUTO) {\r\n      this._calculatedThreshold = this._params.threshold;\r\n      return this._calculatedThreshold;\r\n    }\r\n\r\n    var twoThresholds = this._getImageHistogram().multilevelThresholding(2);\r\n    this._calculatedThreshold = this._params.blackOnWhite ? twoThresholds[1] : twoThresholds[0];\r\n    this._calculatedThreshold = this._calculatedThreshold || 128;\r\n\r\n    return this._calculatedThreshold;\r\n  },\r\n\r\n  /**\r\n   * Running potrace on the image multiple times with different thresholds and returns an array\r\n   * of path tags\r\n   *\r\n   * @param {Boolean} [noFillColor]\r\n   * @returns {string[]}\r\n   * @private\r\n   */\r\n  _pathTags: function(noFillColor) {\r\n    var ranges = this._getRanges();\r\n    var potrace = this._potrace;\r\n    var blackOnWhite = this._params.blackOnWhite;\r\n\r\n    if (ranges.length >= 10) {\r\n      ranges = this._addExtraColorStop(ranges);\r\n    }\r\n\r\n    potrace.setParameters({ blackOnWhite: blackOnWhite });\r\n\r\n    var actualPrevLayersOpacity = 0;\r\n\r\n    return ranges.map(function(colorStop) {\r\n      var thisLayerOpacity = colorStop.colorIntensity;\r\n\r\n      if (thisLayerOpacity === 0) {\r\n        return '';\r\n      }\r\n\r\n      // NOTE: With big number of layers (something like 70) there will be noticeable math error on rendering side.\r\n      // In Chromium at least image will end up looking brighter overall compared to the same layers painted in solid colors.\r\n      // However it works fine with sane number of layers, and it's not like we can do much about it.\r\n\r\n      var calculatedOpacity = (!actualPrevLayersOpacity || thisLayerOpacity === 1)\r\n        ? thisLayerOpacity\r\n        : ((actualPrevLayersOpacity - thisLayerOpacity) / (actualPrevLayersOpacity - 1));\r\n\r\n      calculatedOpacity = utils.clamp(parseFloat(calculatedOpacity.toFixed(3)), 0, 1);\r\n      actualPrevLayersOpacity = actualPrevLayersOpacity + (1 - actualPrevLayersOpacity) * calculatedOpacity;\r\n\r\n      potrace.setParameters({ threshold: colorStop.value });\r\n\r\n      var element = noFillColor ? potrace.getPathTag('') : potrace.getPathTag();\r\n      element = utils.setHtmlAttr(element, 'fill-opacity', calculatedOpacity.toFixed(3));\r\n\r\n      var canBeIgnored = calculatedOpacity === 0 || element.indexOf(' d=\"\"') !== -1;\r\n\r\n      // var c = Math.round(Math.abs((blackOnWhite ? 255 : 0) - 255 * thisLayerOpacity));\r\n      // element = utils.setHtmlAttr(element, 'fill', 'rgb('+c+', '+c+', '+c+')');\r\n      // element = utils.setHtmlAttr(element, 'fill-opacity', '');\r\n\r\n      return canBeIgnored ? '' : element;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Loads image.\r\n   *\r\n   * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP\r\n   * @param {Function} callback\r\n   */\r\n  loadImage: function(target, callback) {\r\n    var self = this;\r\n\r\n    this._potrace.loadImage(target, function(err) {\r\n      self._calculatedThreshold = null;\r\n      callback.call(self, err);\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Sets parameters. Accepts same object as {Potrace}\r\n   *\r\n   * @param {Posterizer~Options} params\r\n   */\r\n  setParameters: function(params) {\r\n    if (!params) {\r\n      return;\r\n    }\r\n\r\n    this._potrace.setParameters(params);\r\n\r\n    if (params.steps && !Array.isArray(params.steps) && (!utils.isNumber(params.steps) || !utils.between(params.steps, 1, 255))) {\r\n      throw new Error('Bad \\'steps\\' value');\r\n    }\r\n\r\n    for (var key in this._params) {\r\n      if (this._params.hasOwnProperty(key) && params.hasOwnProperty(key)) {\r\n        this._params[key] = params[key];\r\n      }\r\n    }\r\n\r\n    this._calculatedThreshold = null;\r\n  },\r\n\r\n  /**\r\n   * Returns image as <symbol> tag. Always has viewBox specified\r\n   *\r\n   * @param {string} id\r\n   */\r\n  getSymbol: function(id) {\r\n    var width = this._potrace._luminanceData.width;\r\n    var height = this._potrace._luminanceData.height;\r\n    var paths = this._pathTags(true);\r\n\r\n    return '<symbol viewBox=\"0 0 ' + width + ' ' + height + '\" id=\"' + id + '\">' +\r\n      paths.join('') +\r\n      '</symbol>';\r\n  },\r\n\r\n  /**\r\n   * Generates SVG image\r\n   * @returns {String}\r\n   */\r\n  getSVG: function() {\r\n    var width = this._potrace._luminanceData.width,\r\n        height = this._potrace._luminanceData.height;\r\n\r\n    var tags = this._pathTags(false);\r\n\r\n    var svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' +\r\n      'width=\"' + width + '\" ' +\r\n      'height=\"' + height + '\" ' +\r\n      'viewBox=\"0 0 ' + width + ' ' + height + '\" ' +\r\n      'version=\"1.1\">\\n\\t' +\r\n      (this._params.background !== Potrace.COLOR_TRANSPARENT\r\n        ? '<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"' + this._params.background + '\" />\\n\\t'\r\n        : '') +\r\n      tags.join('\\n\\t') +\r\n      '\\n</svg>';\r\n\r\n    return svg.replace(/\\n(?:\\t*\\n)+(\\t*)/g, '\\n$1');\r\n  }\r\n};\r\n\r\nmodule.exports = Posterizer;\r\n\r\n/**\r\n * Posterizer options\r\n *\r\n * @typedef {Potrace~Options} Posterizer~Options\r\n * @property {Number} [steps]   - Number of samples that needs to be taken (and number of layers in SVG). (default: Posterizer.STEPS_AUTO, which most likely will result in 3, sometimes 4)\r\n * @property {*} [fillStrategy] - How to select fill color for color ranges - equally spread or dominant. (default: Posterizer.FILL_DOMINANT)\r\n * @property {*} [rangeDistribution] - How to choose thresholds in-between - after equal intervals or automatically balanced. (default: Posterizer.RANGES_AUTO)\r\n */\r\n"]},"metadata":{},"sourceType":"script"}