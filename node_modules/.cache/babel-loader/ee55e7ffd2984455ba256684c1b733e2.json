{"ast":null,"code":"\"use strict\"; // Histogram\n\nvar utils = require('../utils');\n\nvar Jimp = null;\n\ntry {\n  Jimp = require('jimp');\n} catch (e) {}\n\nvar Bitmap = require('./Bitmap');\n\nvar COLOR_DEPTH = 256;\nvar COLOR_RANGE_END = COLOR_DEPTH - 1;\n/**\r\n * Calculates array index for pair of indexes. We multiple column (x) by 256 and then add row to it,\r\n * this way `(index(i, j) + 1) === index(i, j + i)` thus we can reuse `index(i, j)` we once calculated\r\n *\r\n * Note: this is different from how indexes calculated in {@link Bitmap} class, keep it in mind.\r\n *\r\n * @param x\r\n * @param y\r\n * @returns {*}\r\n * @private\r\n */\n\nfunction index(x, y) {\n  return COLOR_DEPTH * x + y;\n}\n\nfunction normalizeMinMax(levelMin, levelMax) {\n  /**\r\n   * Shared parameter normalization for methods 'multilevelThresholding', 'autoThreshold', 'getDominantColor' and 'getStats'\r\n   *\r\n   * @param levelMin\r\n   * @param levelMax\r\n   * @returns {number[]}\r\n   * @private\r\n   */\n  levelMin = typeof levelMin === 'number' ? utils.clamp(Math.round(levelMin), 0, COLOR_RANGE_END) : 0;\n  levelMax = typeof levelMax === 'number' ? utils.clamp(Math.round(levelMax), 0, COLOR_RANGE_END) : COLOR_RANGE_END;\n\n  if (levelMin > levelMax) {\n    throw new Error('Invalid range \"' + levelMin + '...' + levelMax + '\"');\n  }\n\n  return [levelMin, levelMax];\n}\n/**\r\n * 1D Histogram\r\n *\r\n * @param {Number|Bitmap|Jimp} imageSource - Image to collect pixel data from. Or integer to create empty histogram for image of specific size\r\n * @param [mode] Used only for Jimp images. {@link Bitmap} currently can only store 256 values per pixel, so it's assumed that it contains values we are looking for\r\n * @constructor\r\n * @protected\r\n */\n\n\nfunction Histogram(imageSource, mode) {\n  this.data = null;\n  this.pixels = 0;\n  this._sortedIndexes = null;\n  this._cachedStats = {};\n  this._lookupTableH = null;\n\n  if (typeof imageSource === 'number') {\n    this._createArray(imageSource);\n  } else if (imageSource instanceof Bitmap) {\n    this._collectValuesBitmap(imageSource);\n  } else if (Jimp && imageSource instanceof Jimp) {\n    this._collectValuesJimp(imageSource, mode);\n  } else {\n    throw new Error('Unsupported image source');\n  }\n}\n\nHistogram.MODE_LUMINANCE = 'luminance';\nHistogram.MODE_R = 'r';\nHistogram.MODE_G = 'g';\nHistogram.MODE_B = 'b';\nHistogram.prototype = {\n  /**\r\n   * Initializes data array for an image of given pixel size\r\n   * @param imageSize\r\n   * @returns {Uint8Array|Uint16Array|Uint32Array}\r\n   * @private\r\n   */\n  _createArray: function (imageSize) {\n    var ArrayType = imageSize <= Math.pow(2, 8) ? Uint8Array : imageSize <= Math.pow(2, 16) ? Uint16Array : Uint32Array;\n    this.pixels = imageSize;\n    return this.data = new ArrayType(COLOR_DEPTH);\n  },\n\n  /**\r\n   * Aggregates color data from {@link Jimp} instance\r\n   * @param {Jimp} source\r\n   * @param mode\r\n   * @private\r\n   */\n  _collectValuesJimp: function (source, mode) {\n    var pixelData = source.bitmap.data;\n\n    var data = this._createArray(source.bitmap.width * source.bitmap.height);\n\n    source.scan(0, 0, source.bitmap.width, source.bitmap.height, function (x, y, idx) {\n      var val = mode === Histogram.MODE_R ? pixelData[idx] : mode === Histogram.MODE_G ? pixelData[idx + 1] : mode === Histogram.MODE_B ? pixelData[idx + 2] : utils.luminance(pixelData[idx], pixelData[idx + 1], pixelData[idx + 2]);\n      data[val]++;\n    });\n  },\n\n  /**\r\n   * Aggregates color data from {@link Bitmap} instance\r\n   * @param {Bitmap} source\r\n   * @private\r\n   */\n  _collectValuesBitmap: function (source) {\n    var data = this._createArray(source.size);\n\n    var len = source.data.length;\n    var color;\n\n    for (var i = 0; i < len; i++) {\n      color = source.data[i];\n      data[color]++;\n    }\n  },\n\n  /**\r\n   * Returns array of color indexes in ascending order\r\n   * @param refresh\r\n   * @returns {*}\r\n   * @private\r\n   */\n  _getSortedIndexes: function (refresh) {\n    if (!refresh && this._sortedIndexes) {\n      return this._sortedIndexes;\n    }\n\n    var data = this.data;\n    var indexes = new Array(COLOR_DEPTH);\n    var i = 0;\n\n    for (i; i < COLOR_DEPTH; i++) {\n      indexes[i] = i;\n    }\n\n    indexes.sort(function (a, b) {\n      return data[a] > data[b] ? 1 : data[a] < data[b] ? -1 : 0;\n    });\n    this._sortedIndexes = indexes;\n    return indexes;\n  },\n\n  /**\r\n   * Builds lookup table H from lookup tables P and S.\r\n   * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details\r\n   *\r\n   * @returns {Float64Array}\r\n   * @private\r\n   */\n  _thresholdingBuildLookupTable: function () {\n    var P = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);\n    var S = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);\n    var H = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);\n    var pixelsTotal = this.pixels;\n    var i, j, idx, tmp; // diagonal\n\n    for (i = 1; i < COLOR_DEPTH; ++i) {\n      idx = index(i, i);\n      tmp = this.data[i] / pixelsTotal;\n      P[idx] = tmp;\n      S[idx] = i * tmp;\n    } // calculate first row (row 0 is all zero)\n\n\n    for (i = 1; i < COLOR_DEPTH - 1; ++i) {\n      tmp = this.data[i + 1] / pixelsTotal;\n      idx = index(1, i);\n      P[idx + 1] = P[idx] + tmp;\n      S[idx + 1] = S[idx] + (i + 1) * tmp;\n    } // using row 1 to calculate others\n\n\n    for (i = 2; i < COLOR_DEPTH; i++) {\n      for (j = i + 1; j < COLOR_DEPTH; j++) {\n        P[index(i, j)] = P[index(1, j)] - P[index(1, i - 1)];\n        S[index(i, j)] = S[index(1, j)] - S[index(1, i - 1)];\n      }\n    } // now calculate H[i][j]\n\n\n    for (i = 1; i < COLOR_DEPTH; ++i) {\n      for (j = i + 1; j < COLOR_DEPTH; j++) {\n        idx = index(i, j);\n        H[idx] = P[idx] !== 0 ? S[idx] * S[idx] / P[idx] : 0;\n      }\n    }\n\n    return this._lookupTableH = H;\n  },\n\n  /**\r\n   * Implements Algorithm For Multilevel Thresholding\r\n   * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax\r\n   *\r\n   * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram\r\n   *\r\n   * @param amount - how many thresholds should be calculated\r\n   * @param [levelMin=0] - histogram segment start\r\n   * @param [levelMax=255] - histogram segment end\r\n   * @returns {number[]}\r\n  */\n  multilevelThresholding: function (amount, levelMin, levelMax) {\n    levelMin = normalizeMinMax(levelMin, levelMax);\n    levelMax = levelMin[1];\n    levelMin = levelMin[0];\n    amount = Math.min(levelMax - levelMin - 2, ~~amount);\n\n    if (amount < 1) {\n      return [];\n    }\n\n    if (!this._lookupTableH) {\n      this._thresholdingBuildLookupTable();\n    }\n\n    var H = this._lookupTableH;\n    var colorStops = null;\n    var maxSig = 0;\n\n    if (amount > 4) {\n      console.log('[Warning]: Threshold computation for more than 5 levels may take a long time');\n    }\n\n    function iterateRecursive(startingPoint, prevVariance, indexes, previousDepth) {\n      startingPoint = (startingPoint || 0) + 1;\n      prevVariance = prevVariance || 0;\n      indexes = indexes || new Array(amount);\n      previousDepth = previousDepth || 0;\n      var depth = previousDepth + 1; // t\n\n      var variance;\n\n      for (var i = startingPoint; i < levelMax - amount + previousDepth; i++) {\n        variance = prevVariance + H[index(startingPoint, i)];\n        indexes[depth - 1] = i;\n\n        if (depth + 1 < amount + 1) {\n          // we need to go deeper\n          iterateRecursive(i, variance, indexes, depth);\n        } else {\n          // enough, we can compare values now\n          variance += H[index(i + 1, levelMax)];\n\n          if (maxSig < variance) {\n            maxSig = variance;\n            colorStops = indexes.slice();\n          }\n        }\n      }\n    }\n\n    iterateRecursive(levelMin || 0);\n    return colorStops ? colorStops : [];\n  },\n\n  /**\r\n   * Automatically finds threshold value using Algorithm For Multilevel Thresholding\r\n   *\r\n   * @param {number} [levelMin]\r\n   * @param {number} [levelMax]\r\n   * @returns {null|number}\r\n   */\n  autoThreshold: function (levelMin, levelMax) {\n    var value = this.multilevelThresholding(1, levelMin, levelMax);\n    return value.length ? value[0] : null;\n  },\n\n  /**\r\n   * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image\r\n   *\r\n   * @param [levelMin=0]\r\n   * @param [levelMax=255]\r\n   * @param [tolerance=1]\r\n   * @returns {number}\r\n   */\n  getDominantColor: function (levelMin, levelMax, tolerance) {\n    levelMin = normalizeMinMax(levelMin, levelMax);\n    levelMax = levelMin[1];\n    levelMin = levelMin[0];\n    tolerance = tolerance || 1;\n    var colors = this.data,\n        dominantIndex = -1,\n        dominantValue = -1,\n        i,\n        j,\n        tmp;\n\n    if (levelMin === levelMax) {\n      return colors[levelMin] ? levelMin : -1;\n    }\n\n    for (i = levelMin; i <= levelMax; i++) {\n      tmp = 0;\n\n      for (j = ~~(tolerance / -2); j < tolerance; j++) {\n        tmp += utils.between(i + j, 0, COLOR_RANGE_END) ? colors[i + j] : 0;\n      }\n\n      var summIsBigger = tmp > dominantValue;\n      var summEqualButMainColorIsBigger = dominantValue === tmp && (dominantIndex < 0 || colors[i] > colors[dominantIndex]);\n\n      if (summIsBigger || summEqualButMainColorIsBigger) {\n        dominantIndex = i;\n        dominantValue = tmp;\n      }\n    }\n\n    return dominantValue <= 0 ? -1 : dominantIndex;\n  },\n\n  /**\r\n   * Returns stats for histogram or its segment.\r\n   *\r\n   * Returned object contains median, mean and standard deviation for pixel values;\r\n   * peak, mean and median number of pixels per level and few other values\r\n   *\r\n   * If no pixels colors from specified range present on the image - most values will be NaN\r\n   *\r\n   * @param {Number} [levelMin=0] - histogram segment start\r\n   * @param {Number} [levelMax=255] - histogram segment end\r\n   * @param {Boolean} [refresh=false] - if cached result can be returned\r\n   * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}\r\n   */\n  getStats: function (levelMin, levelMax, refresh) {\n    levelMin = normalizeMinMax(levelMin, levelMax);\n    levelMax = levelMin[1];\n    levelMin = levelMin[0];\n\n    if (!refresh && this._cachedStats[levelMin + '-' + levelMax]) {\n      return this._cachedStats[levelMin + '-' + levelMax];\n    }\n\n    var data = this.data;\n\n    var sortedIndexes = this._getSortedIndexes();\n\n    var pixelsTotal = 0;\n    var medianValue = null;\n    var meanValue;\n    var medianPixelIndex;\n    var pixelsPerLevelMean;\n    var pixelsPerLevelMedian;\n    var tmpSumOfDeviations = 0;\n    var tmpPixelsIterated = 0;\n    var allPixelValuesCombined = 0;\n    var i, tmpPixels, tmpPixelValue;\n    var uniqueValues = 0; // counter for levels that's represented by at least one pixel\n\n    var mostPixelsPerLevel = 0; // Finding number of pixels and mean\n\n    for (i = levelMin; i <= levelMax; i++) {\n      pixelsTotal += data[i];\n      allPixelValuesCombined += data[i] * i;\n      uniqueValues += data[i] === 0 ? 0 : 1;\n\n      if (mostPixelsPerLevel < data[i]) {\n        mostPixelsPerLevel = data[i];\n      }\n    }\n\n    meanValue = allPixelValuesCombined / pixelsTotal;\n    pixelsPerLevelMean = pixelsTotal / (levelMax - levelMin);\n    pixelsPerLevelMedian = pixelsTotal / uniqueValues;\n    medianPixelIndex = Math.floor(pixelsTotal / 2); // Finding median and standard deviation\n\n    for (i = 0; i < COLOR_DEPTH; i++) {\n      tmpPixelValue = sortedIndexes[i];\n      tmpPixels = data[tmpPixelValue];\n\n      if (tmpPixelValue < levelMin || tmpPixelValue > levelMax) {\n        continue;\n      }\n\n      tmpPixelsIterated += tmpPixels;\n      tmpSumOfDeviations += Math.pow(tmpPixelValue - meanValue, 2) * tmpPixels;\n\n      if (medianValue === null && tmpPixelsIterated >= medianPixelIndex) {\n        medianValue = tmpPixelValue;\n      }\n    }\n\n    return this._cachedStats[levelMin + '-' + levelMax] = {\n      // various pixel counts for levels (0..255)\n      levels: {\n        mean: meanValue,\n        median: medianValue,\n        stdDev: Math.sqrt(tmpSumOfDeviations / pixelsTotal),\n        unique: uniqueValues\n      },\n      // what's visually represented as bars\n      pixelsPerLevel: {\n        mean: pixelsPerLevelMean,\n        median: pixelsPerLevelMedian,\n        peak: mostPixelsPerLevel\n      },\n      pixels: pixelsTotal\n    };\n  }\n};\nmodule.exports = Histogram;","map":{"version":3,"sources":["/Users/zakstratton/Documents/design-tool/node_modules/potrace/lib/types/Histogram.js"],"names":["utils","require","Jimp","e","Bitmap","COLOR_DEPTH","COLOR_RANGE_END","index","x","y","normalizeMinMax","levelMin","levelMax","clamp","Math","round","Error","Histogram","imageSource","mode","data","pixels","_sortedIndexes","_cachedStats","_lookupTableH","_createArray","_collectValuesBitmap","_collectValuesJimp","MODE_LUMINANCE","MODE_R","MODE_G","MODE_B","prototype","imageSize","ArrayType","pow","Uint8Array","Uint16Array","Uint32Array","source","pixelData","bitmap","width","height","scan","idx","val","luminance","size","len","length","color","i","_getSortedIndexes","refresh","indexes","Array","sort","a","b","_thresholdingBuildLookupTable","P","Float64Array","S","H","pixelsTotal","j","tmp","multilevelThresholding","amount","min","colorStops","maxSig","console","log","iterateRecursive","startingPoint","prevVariance","previousDepth","depth","variance","slice","autoThreshold","value","getDominantColor","tolerance","colors","dominantIndex","dominantValue","between","summIsBigger","summEqualButMainColorIsBigger","getStats","sortedIndexes","medianValue","meanValue","medianPixelIndex","pixelsPerLevelMean","pixelsPerLevelMedian","tmpSumOfDeviations","tmpPixelsIterated","allPixelValuesCombined","tmpPixels","tmpPixelValue","uniqueValues","mostPixelsPerLevel","floor","levels","mean","median","stdDev","sqrt","unique","pixelsPerLevel","peak","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\n// Histogram\r\n\r\nvar utils = require('../utils');\r\nvar Jimp = null; try { Jimp = require('jimp'); } catch(e) {}\r\nvar Bitmap = require('./Bitmap');\r\n\r\nvar COLOR_DEPTH = 256;\r\nvar COLOR_RANGE_END = COLOR_DEPTH - 1;\r\n\r\n/**\r\n * Calculates array index for pair of indexes. We multiple column (x) by 256 and then add row to it,\r\n * this way `(index(i, j) + 1) === index(i, j + i)` thus we can reuse `index(i, j)` we once calculated\r\n *\r\n * Note: this is different from how indexes calculated in {@link Bitmap} class, keep it in mind.\r\n *\r\n * @param x\r\n * @param y\r\n * @returns {*}\r\n * @private\r\n */\r\nfunction index(x, y) {\r\n  return COLOR_DEPTH * x + y;\r\n}\r\n\r\nfunction normalizeMinMax(levelMin, levelMax) {\r\n  /**\r\n   * Shared parameter normalization for methods 'multilevelThresholding', 'autoThreshold', 'getDominantColor' and 'getStats'\r\n   *\r\n   * @param levelMin\r\n   * @param levelMax\r\n   * @returns {number[]}\r\n   * @private\r\n   */\r\n  levelMin = typeof levelMin === 'number' ? utils.clamp(Math.round(levelMin), 0, COLOR_RANGE_END) : 0;\r\n  levelMax = typeof levelMax === 'number' ? utils.clamp(Math.round(levelMax), 0, COLOR_RANGE_END) : COLOR_RANGE_END;\r\n\r\n  if (levelMin > levelMax) {\r\n    throw new Error('Invalid range \"'+ levelMin + '...' + levelMax + '\"');\r\n  }\r\n\r\n  return [levelMin, levelMax];\r\n}\r\n\r\n/**\r\n * 1D Histogram\r\n *\r\n * @param {Number|Bitmap|Jimp} imageSource - Image to collect pixel data from. Or integer to create empty histogram for image of specific size\r\n * @param [mode] Used only for Jimp images. {@link Bitmap} currently can only store 256 values per pixel, so it's assumed that it contains values we are looking for\r\n * @constructor\r\n * @protected\r\n */\r\nfunction Histogram(imageSource, mode) {\r\n  this.data = null;\r\n  this.pixels = 0;\r\n  this._sortedIndexes = null;\r\n  this._cachedStats = {};\r\n  this._lookupTableH = null;\r\n\r\n  if (typeof imageSource === 'number') {\r\n    this._createArray(imageSource);\r\n  } else if (imageSource instanceof Bitmap) {\r\n    this._collectValuesBitmap(imageSource);\r\n  } else if (Jimp && imageSource instanceof Jimp) {\r\n    this._collectValuesJimp(imageSource, mode);\r\n  } else {\r\n    throw new Error('Unsupported image source');\r\n  }\r\n}\r\n\r\nHistogram.MODE_LUMINANCE = 'luminance';\r\nHistogram.MODE_R = 'r';\r\nHistogram.MODE_G = 'g';\r\nHistogram.MODE_B = 'b';\r\n\r\nHistogram.prototype = {\r\n  /**\r\n   * Initializes data array for an image of given pixel size\r\n   * @param imageSize\r\n   * @returns {Uint8Array|Uint16Array|Uint32Array}\r\n   * @private\r\n   */\r\n  _createArray: function(imageSize) {\r\n    var ArrayType = imageSize <= Math.pow(2, 8) ? Uint8Array\r\n      : imageSize <= Math.pow(2, 16) ? Uint16Array : Uint32Array;\r\n\r\n    this.pixels = imageSize;\r\n    \r\n    return this.data = new ArrayType(COLOR_DEPTH);\r\n  },\r\n\r\n  /**\r\n   * Aggregates color data from {@link Jimp} instance\r\n   * @param {Jimp} source\r\n   * @param mode\r\n   * @private\r\n   */\r\n  _collectValuesJimp: function(source, mode) {\r\n    var pixelData = source.bitmap.data;\r\n    var data = this._createArray(source.bitmap.width * source.bitmap.height);\r\n\r\n    source.scan(0, 0, source.bitmap.width, source.bitmap.height, function(x, y, idx) {\r\n      var val = mode === Histogram.MODE_R ? pixelData[idx]\r\n        : mode === Histogram.MODE_G ? pixelData[idx + 1]\r\n        : mode === Histogram.MODE_B ? pixelData[idx + 2]\r\n        : utils.luminance(pixelData[idx], pixelData[idx + 1], pixelData[idx + 2]);\r\n\r\n      data[val]++;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Aggregates color data from {@link Bitmap} instance\r\n   * @param {Bitmap} source\r\n   * @private\r\n   */\r\n  _collectValuesBitmap: function(source) {\r\n    var data = this._createArray(source.size);\r\n    var len = source.data.length;\r\n    var color;\r\n\r\n    for (var i = 0; i < len; i++) {\r\n      color = source.data[i];\r\n      data[color]++\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns array of color indexes in ascending order\r\n   * @param refresh\r\n   * @returns {*}\r\n   * @private\r\n   */\r\n  _getSortedIndexes: function(refresh) {\r\n    if (!refresh && this._sortedIndexes) {\r\n      return this._sortedIndexes;\r\n    }\r\n\r\n    var data = this.data;\r\n    var indexes = new Array(COLOR_DEPTH);\r\n    var i = 0;\r\n\r\n    for (i; i < COLOR_DEPTH; i++) {\r\n      indexes[i] = i;\r\n    }\r\n\r\n    indexes.sort(function(a, b) {\r\n      return data[a] > data[b] ? 1 : data[a] < data[b] ? -1 : 0;\r\n    });\r\n\r\n    this._sortedIndexes = indexes;\r\n    return indexes;\r\n  },\r\n\r\n  /**\r\n   * Builds lookup table H from lookup tables P and S.\r\n   * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details\r\n   *\r\n   * @returns {Float64Array}\r\n   * @private\r\n   */\r\n  _thresholdingBuildLookupTable: function() {\r\n    var P = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);\r\n    var S = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);\r\n    var H = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);\r\n    var pixelsTotal = this.pixels;\r\n    var i, j, idx, tmp;\r\n\r\n    // diagonal\r\n    for (i = 1; i < COLOR_DEPTH; ++i) {\r\n      idx = index(i, i);\r\n      tmp = this.data[i] / pixelsTotal;\r\n\r\n      P[idx] = tmp;\r\n      S[idx] = i * tmp;\r\n    }\r\n\r\n    // calculate first row (row 0 is all zero)\r\n    for (i = 1; i < COLOR_DEPTH - 1; ++i) {\r\n      tmp = this.data[i + 1] / pixelsTotal;\r\n      idx = index(1, i);\r\n\r\n      P[idx+1] = P[idx] + tmp;\r\n      S[idx+1] = S[idx] + (i + 1) * tmp;\r\n    }\r\n\r\n    // using row 1 to calculate others\r\n    for (i = 2; i < COLOR_DEPTH; i++) {\r\n      for (j=i+1; j < COLOR_DEPTH; j++) {\r\n        P[index(i, j)] = P[index(1, j)] - P[index(1, i-1)];\r\n        S[index(i, j)] = S[index(1, j)] - S[index(1, i-1)];\r\n      }\r\n    }\r\n\r\n    // now calculate H[i][j]\r\n    for (i = 1; i < COLOR_DEPTH; ++i) {\r\n      for (j = i + 1; j < COLOR_DEPTH; j++) {\r\n        idx = index(i, j);\r\n        H[idx] = P[idx] !== 0 ? S[idx] * S[idx] / P[idx] : 0;\r\n      }\r\n    }\r\n    \r\n    return this._lookupTableH = H;\r\n  },\r\n\r\n  /**\r\n   * Implements Algorithm For Multilevel Thresholding\r\n   * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax\r\n   *\r\n   * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram\r\n   *\r\n   * @param amount - how many thresholds should be calculated\r\n   * @param [levelMin=0] - histogram segment start\r\n   * @param [levelMax=255] - histogram segment end\r\n   * @returns {number[]}\r\n\t */\r\n  multilevelThresholding: function (amount, levelMin, levelMax) {\r\n    levelMin = normalizeMinMax(levelMin, levelMax);\r\n    levelMax = levelMin[1];\r\n    levelMin = levelMin[0];\r\n    amount = Math.min(levelMax - levelMin - 2, ~~amount);\r\n\r\n    if (amount < 1) {\r\n      return [];\r\n    }\r\n\r\n    if (!this._lookupTableH) {\r\n      this._thresholdingBuildLookupTable();\r\n    }\r\n\r\n    var H = this._lookupTableH;\r\n    \r\n    var colorStops = null;\r\n    var maxSig = 0;\r\n\r\n    if (amount > 4) {\r\n      console.log('[Warning]: Threshold computation for more than 5 levels may take a long time');\r\n    }\r\n\r\n    function iterateRecursive (startingPoint, prevVariance, indexes, previousDepth) {\r\n      startingPoint = (startingPoint || 0) + 1;\r\n      prevVariance = prevVariance || 0;\r\n      indexes = indexes || (new Array(amount));\r\n      previousDepth = previousDepth || 0;\r\n\r\n      var depth = previousDepth + 1; // t\r\n      var variance;\r\n\r\n      for (var i = startingPoint; i < levelMax - amount + previousDepth; i++) {\r\n        variance = prevVariance + H[index(startingPoint, i)];\r\n        indexes[depth - 1] = i;\r\n\r\n\t      if (depth + 1 < amount + 1) {\r\n          // we need to go deeper\r\n          iterateRecursive(i, variance, indexes, depth);\r\n        } else {\r\n          // enough, we can compare values now\r\n          variance += H[index(i + 1, levelMax)];\r\n\r\n          if (maxSig < variance) {\r\n            maxSig = variance;\r\n            colorStops = indexes.slice();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    iterateRecursive(levelMin || 0);\r\n\r\n    return colorStops ? colorStops : [];\r\n  },\r\n\r\n  /**\r\n   * Automatically finds threshold value using Algorithm For Multilevel Thresholding\r\n   *\r\n   * @param {number} [levelMin]\r\n   * @param {number} [levelMax]\r\n   * @returns {null|number}\r\n   */\r\n  autoThreshold: function(levelMin, levelMax) {\r\n    var value = this.multilevelThresholding(1, levelMin, levelMax);\r\n    return value.length ? value[0] : null;\r\n  },\r\n\r\n  /**\r\n   * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image\r\n   *\r\n   * @param [levelMin=0]\r\n   * @param [levelMax=255]\r\n   * @param [tolerance=1]\r\n   * @returns {number}\r\n   */\r\n  getDominantColor: function(levelMin, levelMax, tolerance) {\r\n    levelMin = normalizeMinMax(levelMin, levelMax);\r\n    levelMax = levelMin[1];\r\n    levelMin = levelMin[0];\r\n    tolerance = tolerance || 1;\r\n\r\n    var colors = this.data,\r\n        dominantIndex = -1,\r\n        dominantValue = -1,\r\n        i, j, tmp;\r\n\r\n    if (levelMin === levelMax) {\r\n      return colors[levelMin] ? levelMin : -1;\r\n    }\r\n\r\n    for (i=levelMin; i <= levelMax; i++) {\r\n      tmp = 0;\r\n\r\n      for (j = ~~(tolerance / -2); j < tolerance; j++) {\r\n        tmp += utils.between(i + j, 0, COLOR_RANGE_END) ? colors[i + j] : 0;\r\n      }\r\n\r\n      var summIsBigger = tmp > dominantValue;\r\n      var summEqualButMainColorIsBigger = dominantValue === tmp && (dominantIndex < 0 || colors[i] > colors[dominantIndex]);\r\n\r\n      if (summIsBigger || summEqualButMainColorIsBigger) {\r\n        dominantIndex = i;\r\n        dominantValue = tmp;\r\n      }\r\n    }\r\n\r\n    return dominantValue <= 0 ? -1 : dominantIndex;\r\n  },\r\n\r\n  /**\r\n   * Returns stats for histogram or its segment.\r\n   *\r\n   * Returned object contains median, mean and standard deviation for pixel values;\r\n   * peak, mean and median number of pixels per level and few other values\r\n   *\r\n   * If no pixels colors from specified range present on the image - most values will be NaN\r\n   *\r\n   * @param {Number} [levelMin=0] - histogram segment start\r\n   * @param {Number} [levelMax=255] - histogram segment end\r\n   * @param {Boolean} [refresh=false] - if cached result can be returned\r\n   * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}\r\n   */\r\n  getStats: function(levelMin, levelMax, refresh) {\r\n    levelMin = normalizeMinMax(levelMin, levelMax);\r\n    levelMax = levelMin[1];\r\n    levelMin = levelMin[0];\r\n\r\n    if (!refresh && this._cachedStats[levelMin + '-' + levelMax]) {\r\n      return this._cachedStats[levelMin + '-' + levelMax];\r\n    }\r\n\r\n    var data = this.data;\r\n    var sortedIndexes = this._getSortedIndexes();\r\n\r\n    var pixelsTotal = 0;\r\n    var medianValue = null;\r\n    var meanValue;\r\n    var medianPixelIndex;\r\n    var pixelsPerLevelMean;\r\n    var pixelsPerLevelMedian;\r\n    var tmpSumOfDeviations = 0;\r\n    var tmpPixelsIterated = 0;\r\n    var allPixelValuesCombined = 0;\r\n    var i, tmpPixels, tmpPixelValue;\r\n\r\n    var uniqueValues = 0; // counter for levels that's represented by at least one pixel\r\n    var mostPixelsPerLevel = 0;\r\n\r\n    // Finding number of pixels and mean\r\n\r\n    for (i = levelMin; i <= levelMax; i++) {\r\n      pixelsTotal += data[i];\r\n      allPixelValuesCombined += data[i] * i;\r\n\r\n      uniqueValues += data[i] === 0 ? 0 : 1;\r\n\r\n      if (mostPixelsPerLevel < data[i]) {\r\n        mostPixelsPerLevel = data[i];\r\n      }\r\n    }\r\n\r\n    meanValue = allPixelValuesCombined / pixelsTotal;\r\n    pixelsPerLevelMean = pixelsTotal / (levelMax - levelMin);\r\n    pixelsPerLevelMedian = pixelsTotal / uniqueValues;\r\n    medianPixelIndex = Math.floor(pixelsTotal / 2);\r\n\r\n    // Finding median and standard deviation\r\n\r\n    for (i = 0; i < COLOR_DEPTH; i++) {\r\n      tmpPixelValue = sortedIndexes[i];\r\n      tmpPixels = data[tmpPixelValue];\r\n\r\n      if (tmpPixelValue < levelMin || tmpPixelValue > levelMax) {\r\n        continue;\r\n      }\r\n\r\n      tmpPixelsIterated += tmpPixels;\r\n      tmpSumOfDeviations += Math.pow(tmpPixelValue - meanValue, 2) * tmpPixels;\r\n\r\n      if (medianValue === null && tmpPixelsIterated >= medianPixelIndex) {\r\n        medianValue = tmpPixelValue;\r\n      }\r\n    }\r\n\r\n    return this._cachedStats[levelMin + '-' + levelMax] = {\r\n      // various pixel counts for levels (0..255)\r\n\r\n      levels: {\r\n        mean: meanValue,\r\n        median: medianValue,\r\n        stdDev: Math.sqrt(tmpSumOfDeviations / pixelsTotal),\r\n        unique: uniqueValues\r\n      },\r\n\r\n      // what's visually represented as bars\r\n      pixelsPerLevel: {\r\n        mean: pixelsPerLevelMean,\r\n        median: pixelsPerLevelMedian,\r\n        peak: mostPixelsPerLevel\r\n      },\r\n\r\n      pixels: pixelsTotal\r\n    };\r\n  }\r\n};\r\n\r\nmodule.exports = Histogram;"]},"metadata":{},"sourceType":"script"}