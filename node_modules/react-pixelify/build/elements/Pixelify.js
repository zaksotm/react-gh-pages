"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Pixelify = function (_Component) {
  _inherits(Pixelify, _Component);

  function Pixelify() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Pixelify);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Pixelify.__proto__ || Object.getPrototypeOf(Pixelify)).call.apply(_ref, [this].concat(args))), _this), _this.canvas = null, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Pixelify, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.pixelify(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.pixelify(this.props);
    }
  }, {
    key: "pixelify",
    value: function pixelify(_ref2) {
      var _this2 = this;

      var src = _ref2.src,
          width = _ref2.width,
          height = _ref2.height,
          pixelSize = _ref2.pixelSize,
          centered = _ref2.centered,
          fillTransparencyColor = _ref2.fillTransparencyColor;

      pixelSize = parseInt(pixelSize, 10);
      // create img that will be later painted into the canvas
      var img = new Image();
      img.src = src;
      // once image is loaded..
      img.onload = function () {
        var canvas = _this2.canvas;
        var ctx = canvas.getContext("2d");
        img.width = width ? width : img.width;
        img.height = height ? height : img.height;
        canvas.width = img.width;
        canvas.height = img.height;
        // we paint the image into the canvas
        // this is needed to get RGBA info out of each pixel
        ctx.drawImage(img, 0, 0, img.width, img.height);
        _this2.paintPixels(ctx, img, pixelSize, centered, fillTransparencyColor);
        img = null;
      };
    }
  }, {
    key: "paintPixels",
    value: function paintPixels(ctx, img, pixelSize, centered, fillTransparencyColor) {
      if (!isNaN(pixelSize) && pixelSize > 0) {
        for (var x = 0; x < img.width + pixelSize; x += pixelSize) {
          for (var y = 0; y < img.height + pixelSize; y += pixelSize) {
            var xColorPick = x;
            var yColorPick = y;

            if (x >= img.width) {
              xColorPick = x - (pixelSize - img.width % pixelSize / 2) + 1;
            }
            if (y >= img.height) {
              yColorPick = y - (pixelSize - img.height % pixelSize / 2) + 1;
            }

            var rgba = ctx.getImageData(xColorPick, yColorPick, 1, 1).data;
            // TODO: add support for png transparent background
            // need to create another canvas and duplicate process?
            // one canvas to get the data from
            // one to paint pixels into
            ctx.fillStyle = rgba[3] === 0 ? fillTransparencyColor : "rgba(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + "," + rgba[3] + ")";

            if (centered) {
              ctx.fillRect(parseInt(x - (pixelSize - img.width % pixelSize / 2), 10), parseInt(y - (pixelSize - img.height % pixelSize / 2), 10), pixelSize, pixelSize);
            } else {
              ctx.fillRect(x, y, pixelSize, pixelSize);
            }
          }
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      return _react2.default.createElement("canvas", {
        ref: function ref(canvas) {
          _this3.canvas = canvas;
        }
      });
    }
  }]);

  return Pixelify;
}(_react.Component);

Pixelify.propTypes = {
  src: _propTypes2.default.string.isRequired,
  pixelSize: _propTypes2.default.number,
  width: _propTypes2.default.number,
  height: _propTypes2.default.number,
  centered: _propTypes2.default.bool,
  fillTransparencyColor: _propTypes2.default.string
};

Pixelify.defaultProps = {
  centered: false,
  fillTransparencyColor: "white"
};

exports.default = Pixelify;